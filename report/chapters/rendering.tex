\chapter{Rendering}

Contemporary polygon-based games almost exclusively rely on specialised triangle rasterisation hardware found in modern GPUs to transform a list of triangles into an image. Unfortunately, it is not possible to use this approach with voxels in their native format and, as previously discussed, it would be too memory-consuming to convert the voxel scene into a polygon representation prior to rendering.

\textit{Ray-casting} is an alternative method of rendering well-suited to voxel data. Ray-casting operates by firing a ray into the voxel scene for every pixel of the screen. If the ray hits a leaf voxel, the pixel is coloured. Since this process is very computationally expensive, it is necessary to harness the processing power of modern graphics hardware to perform many ray-casts in parallel. \textit{Sabre} uses an OpenGL compute shader to perform the actual ray-casting computations.

\section{OpenGL Compute Shaders}
The term \textit{shader} refers to an executable program that runs on the GPU rather than the CPU. Originally applied to very simple programs that performed highly specific tasks such as calculating pixel colours, the term has since come to mean any program that executes on the GPU even if that program has nothing to do with computer graphics.

In OpenGL, compute shaders operate slightly differently to the graphics-specific vertex and fragment shaders. Shader invocations are organised into \textit{work groups} --- multi-dimensional "blocks" of shader execution units. For example, all the elements of a two-dimensional array may be processed in parallel by invoking a compute shader with a work group of the same dimension as the array. The GPU will execute the same compute shader for every work group item.

By representing the screen viewport as a two-dimensional array of texels, a compute shader may be used to compute all of the texel colours in parallel. This serves as the input of the raycasting algorithm.

In this project, the screen viewport is represented by an OpenGL texture object. This texture serves as the output of the renderer compute shader kernel.

\section{Raycasting Algorithm}
Laine and Karras outlined the basic algorithm for SVO raycasting in their original paper. The rendering code for this project is loosely based upon their conceptual algorithm.

The regularity of the SVO data structure allows very efficient raycasting of large voxel data sets because large regions of empty space can be quickly traversed. As defined by Laine and Karras, the voxel raycaster uses three primary operations: \textit{Push} (traverse deeper into a parent voxel), \textit{Advance} (process the next voxel of the same depth) and \textit{Pop} (exit a parent voxel). 

\subsection{Push - Entering a child voxel}
When the raycaster encounters a non-empty voxel, it will first check if the voxel is a leaf. Leaf voxels do not require any further traversal and can be coloured immediately, terminating the ray for this pixel. If the voxel is occupied but not a leaf, we must descend into the SVO hierarchy and examine next node the ray enters --- this is the \textit{push} operation.

Since we may need to return to a voxel from deeper down in the tree (this is the \textit{pop} operation, see section \ref{sec:pop}) we maintain a stack of parent voxels that can be restored if needed.

\subsubsection{Determining the Child Octant}
We can exploit the regularity of the SVO data structure to very quickly determine the octant of a particular world-space point when given the centre position of a parent octree node. First, we observe the fact that any point greater than the centre will lie in the next octant along a given axis; for example points further than halfway along along the \textit{x}-axis will lie in positive-x octants. We can use the built-in GLSL function \texttt{greaterThan} to perform this comparison simultaneously for each axis.

Next, we convert this boolean vector into a vector of integers with values either $0$ or $1$ (corresponding to \texttt{true} and \texttt{false} boolean values). The final octant number is obtained by broadcasting these values into the first, second and third bit indices of an unsigned integer --- listing \ref{listing:getoctant_src} show how this is accomplished using what is effectively an integer dot-product operation. 

\begin{listing}[ht]
\small
\begin{minted}{GLSL}
uint GetOctant(in vec3 P, in vec3 ParentCentreP)
{
  uvec3 G = uvec3(greaterThan(P, ParentCentreP));
  return G.x + G.y*2 + G.z*4;
}

\end{minted}
\caption{GLSL source of the \texttt{GetOctant} function}
\label{listing:getoctant_src}
\end{listing}

\subsubsection{Determining the Child Node}
All SVO nodes contain a child pointer field that indicates the location of the first non-leaf child voxel. To obtain a given node's child, we must first check if the first child is located within the same block as the parent (this does not necessarily imply that the particular child we are looking for is in the same block as its parent). To do this we can inspect the \textit{far-flag} bit of the current node's child pointer bitfield. If this flag is not set, we can interpret the child pointer field as a direct offset into the parent's block. If the far flag is set, we must look up the block index of the first child and skip to that block.

Listing \ref{listing:getnodechild_src} shows the complete source code for the child node lookup procedure. The block index of the parent node \texttt{Blk} is passed as an \texttt{inout} parameter because it must be both read from and written to by \texttt{GetNodeChild}. This is so that the caller can receive an updated current block index in case the child is located in a block different to that of the parent. Note that this can occur even if the parent's first child is located inside the same block as the parent, as illustrated by figure \ref{fig:child_ptr_lookup}.

\begin{figure}[ht]
\footnotesize
    \centering
    \includesvg{graphics/child_ptr_lookup.svg}
    \caption{Child pointers always point to the first non-leaf child (siblings are stored sequentially). In this example, the parent node has three occupied child octants (0, 2 and 3). The first child resides in the same block as its parent, so the child pointer value can be interpreted as an offset into block N.}
    \label{fig:child_ptr_lookup}
\end{figure}
Since siblings always reside side-by-side in memory, it is relatively simple to compute the index of a particular child when given the index of the first child. To find the index of a child node relative to the first child, we first compute a mask of non-leaf octants. We then count the number of set bits lower than the octant we are trying to locate. This produces an offset from the first child.

\begin{listing}[ht]
\small
\linespread{0.80}
\selectfont
\begin{minted}{GLSL}
uint ChildPtr = (Parent & CHILD_PTR_MASK) >> 16;
uint OccBits = (Parent & OCCUPIED_MASK) >> 8; 
uint LeafBits = (Parent & LEAF_MASK);
uint NonLeafMsk = OccBits & (~LeafBits);
uint SibMsk = (1 << Oct) - 1;

uint ChildOffset = bitCount(NonLeafMsk & SibMsk); 
\end{minted}
\caption{Calculating the offset of a child octant \texttt{Oct}}
\label{listing:calculatechildoffset_src}
\end{listing}


\begin{listing}[ht]
\small
\linespread{0.80}
\selectfont
\begin{minted}{GLSL}
uint GetNodeChild(in uint Parent, in uint Oct, inout uint Blk)
{
  uint ChildPtr = (Parent & CHILD_PTR_MASK) >> 16;
  uint OccBits = (Parent & OCCUPIED_MASK) >> 8; 
  uint LeafBits = (Parent & LEAF_MASK);
  uint NonLeafMsk = OccBits & (~LeafBits);
  uint SibMsk = (1 << Oct) - 1;

  uint ChildOffset = bitCount(NonLeafMsk & SibMsk); 

  // Check if we need to look up a far pointer for this child
  if ((Parent & FAR_PTR_BIT_MASK) == 0)
  {
    uint Child = Nodes[Blk*EntriesPerBlk + ChildPtr + ChildOffset];
    
    Blk += (ChildPtr + ChildOffset) / (EntriesPerBlk);

    return Child;
  }
  else
  {
    // Find the far ptr associated with this node. To do this, we need to compute
    // the byte offset for this block, then index into that block's far ptr
    // list for this node.
    uint FarPtrIndex = (Parent & CHILD_PTR_MASK) >> 16;
    uint FarPtrBlkStart = Blk*FarPtrsPerBlk;
    far_ptr FarPtr = FarPtrBuffer[FarPtrBlkStart + FarPtrIndex];

    // Skip to the block containing the first child
    Blk = FarPtr.BlkIndex;
    uint BlkStart = Blk*EntriesPerBlk;

    // Skip any blocks required to get to the actual child node
    Blk += (FarPtr.NodeOffset + ChildOffset) / EntriesPerBlk;

    uint Child = NodeBuffer[BlkStart + FarPtr.NodeOffset + ChildOffset];

    return Child;
  }
}

\end{minted}
\caption{Complete GLSL source code for the \texttt{GetNodeChild} function}
\label{listing:getnodechild_src}
\end{listing}

\subsubsection{Storing the Child Context}
The raycaster maintains a stack of parent voxels which track the ray's progress through the SVO structure. The voxel stack is implemented as a GLSL array of the \texttt{st\_frame} structure outlined in listing \ref{listing:st_frame_struct}

\begin{listing}[ht]
\small
\linespread{0.80}
\selectfont
\begin{minted}{GLSL}
struct st_frame
{
  uint Node;
  int  Scale;
  vec3 ParentCentre;
  uint BlkIndex;
};
\end{minted}
\caption{GLSL source of the \texttt{st\_frame} structure stored in the voxel rendering stack.}
\label{listing:st_frame_struct}
\end{listing}

For each push operation at some depth $d$, a stack entry is created at index $d - 1$. This can then be restored by a later \textit{pop} operation.

\clearpage
\subsection{Advance - Examining a Sibling Voxel}

If the current octant is not occupied, we must advance the current octant to whichever octant of the same scale the ray enters next. To do this, the current octant must be advanced along whichever axes the ray exits the current octant through, i.e. the $t_{max}$ values.

If the current octant is represented with an integer ranging from 0 -- 7, with bit indices corresponding to the $x$, $y$ and $z$ axes respectively, we can determine the next octant's integer representation by flipping the bits for which the $t$-value for that axis matches the $t_{max}$ value. Figure \ref{fig:get_next_oct} shows a two-dimensional example: the current octant is set to $10$ and the $t_{max}$ value corresponds to the $x$-axis, thus we should flip the $x$ bit in this example. By the \texttt{equals()} GLSL intrinsic, we can exploit the fast parallel hardware of the GPU to perform the comparison for all three axes at once. The result of this comparison is a mask that can be XORed with the current octant to produce a candidate next octant (we must still check if the next octant is valid given the direction of the ray; if this is not the case we must execute the \textit{Pop} operation).

\begin{figure}[ht]
    \centering
    \footnotesize
    \includesvg{graphics/get_next_oct.svg}
    \caption{Creating a xor-mask for computing a candidate for the next octant}
    \label{fig:get_next_oct}
\end{figure}


Listing \ref{listing:get_next_octant} shows the GLSL source code for the \texttt{GetNextOctant} function. The code makes use of some GLSL-specific features to avoid costly branching. First, the \texttt{equals} GLSL intrinsic is used to compute a boolean vector representing which components of \texttt{tMaxes} are equal to the \texttt{tMax} value. This is then multiplied by the \texttt{OCT\_BITS} constant vector $(1, 2, 4)$ which is used to shift the values of \texttt{XorMsk3} into the correct bit positions. Finally, the values of \texttt{XorMsk3} are added together to produce the scalar XOR mask that will perform the correct bit-flips on \texttt{CurrentOct}

\begin{listing}[ht]
\begin{minted}{GLSL}
uint GetNextOctant(float tMax, vec3 tMaxes, uint CurrentOct)
{
    // if tMax == tValues.x then NextOct ^= 1;
    // if tMax == tValues.y then NextOct ^= 2;
    // if tMax == tValues.z then NextOct ^= 4;
    uvec3 XorMsk3 = uvec3(equals(vec3(tMax), tMaxes));
    XorMsk3 *= OCT_BITS;
    uint XorMsk = XorMsk3.x + XorMsk3.y + XorMsk3.z;
    return CurrentOct ^ XorMsk;
}
\end{minted}
\caption{GLSL source of the \texttt{GetNextOctant} function}
\label{listing:get_next_octant}
\end{listing}


\clearpage


\label{sec:pop}
\subsection{Pop - Exiting a Voxel}
Whenever the raycaster traverses a parent voxel, but does not actually intersect leaf geometry, the raycaster must exit that parent voxel and proceed to the next voxel of that parent's scale. This is the \textit{pop} operation.

\begin{figure}[ht]
\footnotesize
    \centering
    \includesvg{graphics/pop.svg}
    \caption{Ray exiting octant \textit{A.A} and proceeding to octant \textit{B}. Note the change of scale.}
    \label{fig:pop_example}
\end{figure}

To determine what scale voxel the ray enters next, we must examine the path taken from the ray's starting position through the octree up to this point. By restricting the octree to only positive space, we can determine a path taken through the octree by looking at the binary representation of each coordinate of the ray's current position. For example, in figure \ref{fig:pop_example}, the current node centre position might be $(8, 8)$, while the ray's current position might be $(16, 27)$. Consider the binary representations of these positions:

\begin{figure}
    \small
    \centering
    \includesvg{graphics/bitschk.svg}
    \caption{Deriving an octree path from the bit indices of the ray's current position. In this two dimensional example, it can be seen that the ray is in quadrant 3 (top-right) at scale 16.}
    \label{fig:bit_positions_0}
\end{figure}

By associating each bit position $i$ in these binary numbers with an octree scale value, we can determine which octant the ray has passed through at which a particular scale. We can repeat this process for the centre position of the ray's current octant, giving a path through the octree to the current octant. By comparing these bit vectors, we can determine the scale of the next octant to process. In the example above, the highest differing bit is bit 16, indicating that we exit the current voxel at scale 16. Thus, we can determine the next SVO node to process by restoring parent node to the stack entry at scale 16 and continuing the raycast.

This process hinges on efficiently determining the highest-differing-bit (HDB) between two binary numbers. Fortunately, the GLSL language has a built-in functionality for determining the highest set bit in a given binary number --- the \texttt{findMSB} function. We can combine this function with the standard XOR operator to very quickly determine the highest differing bits in two given uint-vectors. 


\begin{listing}[ht]
\begin{minted}{GLSL}
uvec3 HighestDiffBits(uvec3 V0, uvec3 V1)
{
  // First, determine which bits differ between V0
  // and V1 using the XOR operator. Then, determine
  // the highest set bit in the result.
  return findMSB(V0 ^ V1);
}
\end{minted}
\caption{GLSL source of the \texttt{HighestDiffBits} function}
\label{listing:highestdiffbits_src}
\end{listing}


\section{Renderer Pipeline}
In \textit{Sabre}, the rendering pipeline comprises all of the stages necessary to transfer voxel and auxiliary rendering data onto the GPU, process that data on the GPU and send the output image back to the user's monitor.

Voxel data begins life on the CPU, where it is stored in large blocks linked together by pointers (see section \ref{sec:svo_blocks} for a treatment of CPU-side voxel data storage). In order to render this voxel data, a visible subset of these SVO blocks must be transferred to the GPU as quickly as possible and then rendered to the screen. SVO blocks are stored in a single OpenGL shader storage buffer object (SSBO). 

During the main rendering loop, the main raycasting compute shader is invoked. The GPU will execute one compute shader kernel for each pixel of the output image. Compute shaders are invoked with the OpenGL call \texttt{glDispatchCompute}.

Once the GPU has finished executing the compute shaders, the traditional polygon rendering pipeline is used to present the finished image to the screen. This involves covering the entire viewing window with a flat polygon and then attaching the rendered texture to this polygon. Extremely simple "no-op" fragment and vertex shaders are used to present this image to the screen.



\begin{figure}
    \centering
    \footnotesize
    \includesvg{graphics/render_pipeline.svg}
    \caption{Overview of the \textit{Sabre} rendering pipeline}
    \label{fig:render_pipeline}
\end{figure}